#include "polyinterp.hh"
#include <iostream>

Eigen::Vector3f PolyInterp::evalPt(EvalMethod method, double t) const {
    size_t n = degree();
    if (method == EvalMethod::AITKEN) {
        // TODO: Problem 1.1
        // Implement Aitken's algorithm to interpolate the data pairs {(t_values[i], p[0][i])},
        // filling in the point table stored in member variable `p`.
        return Eigen::Vector3f::Zero();
    }
    if (method == EvalMethod::LAGRANGE) {
        // TODO: Problem 1.4
        // Evaluate the interpolant using the Lagrange basis (O(n^2) time complexity).
        return Eigen::Vector3f::Zero();
    }
    if (method == EvalMethod::LAGRANGE_BARYCENTRIC) {
        // TODO: Problem 1.5
        // Evaluate the interpolant efficiently (O(n) time complexity)
        // using the precomputed weights stored in `w` (which you'll
        // need to implement in `m_samplePointsUpdated` below...).
        return Eigen::Vector3f::Zero();
    }

    throw std::runtime_error("Unknown evaluation method");
}

void PolyInterp::eval(size_t resolution, EvalMethod method, std::vector<Eigen::Vector3f> &result) const {
    // TODO: Problem 1.1
    // Evaluate the discrete polyline approximation to this interpolant in `result`,
    // using `resolution` points evenly spaced over parameter interval [0, 1].
    result.assign(resolution, Eigen::Vector3f::Zero());
}

void PolyInterp::visualizeAitken(double t, Eigen::MatrixX3f &V, Eigen::MatrixX2i &E) const {
    // TODO: Problem 1.3
    // Fill `V` and `E` with an indexed edge set representation of
    // the lines/points generated by Aitken's algorithm.
    size_t n = degree();
    V.resize(0, 3);
    E.resize(0, 2);
}

void PolyInterp::m_samplePointsUpdated() {
    size_t npts = degree() + 1;
    // TODO: Problem 1.3
    // Remove this line!!!
    m_paramType = ParametrizationType::XCOORD; 
    if (m_paramType == ParametrizationType::UNIFORM) {
        // TODO: Problem 1.3
        // Generate `npts` uniformly spaced samples over the parameter interval
        // [0, 1] in `t_values`.
        // Hint: look up Eigen's `setLinSpaced` method...
        throw std::runtime_error("Parametrization::UNIFORM unimplemented");
    }
    else if (m_paramType == ParametrizationType::CHORDLEN) {
        // TODO: Problem 1.3
        // Generate `npts` samples over the parameter interval [0, 1] spaced
        // proportionally to the straight-line distance between data points.
        throw std::runtime_error("Parametrization::CHORDLEN unimplemented");
    }
    else if (m_paramType == ParametrizationType::XCOORD) {
        t_values.resize(npts);
        for (size_t i = 0; i < npts; ++i)
            t_values[i] = p[0][i][0];
        t_values.array() -= t_values.minCoeff();
        t_values /= t_values.maxCoeff();
    }
    else {
        throw std::runtime_error("Unknown parametrization type");
    }

    // TODO: Problem 1.5
    // Precompute the weights w_j to be used for the `LAGRANGE_BARYCENTRIC`
    // O(n) evaluation method.
    w.setOnes(npts);
}
